\documentclass[11pt]{article}
\usepackage[margin=0.5in]{geometry}
\usepackage{comment}

\title {COMP3520 Host Dispatcher Design Document}
\author {Justin Ting, jtin2945, 430203826}
\date {May 2015}

\begin {document}

\maketitle

\section{Memory Allocation Algorithm}

\iffalse
(Provides a thorough description of ALL prescribed memory allocation schemes - 6 marks)
(Provides an informed discussion of the advantages and disadvantages of these schemes)
For each: pros, cons, examples
a. Describe and discuss what memory allocation algorithms you could have used
and justify your final design choice
\fi

A number of memory allocation algorithms were available to choose from for this assignment, and each one will be detailed below - with a description of what they do, their advantages and disadvantages, a worked example that will be consistent across each algorithm, as well as, where applicable, real world cases where they have been used before and how they held up in these situations.\\

The algorithms that were allowed to be chosen from were First Fit, Worst Fit, Next Fit, Best Fit, and the Buddy System, all of which at least partially fall under the category of `Dynamic Partioning` (the latter being in a sense a `combination` of fixed and dynamic partioning), in contrast to `Fixed Partioning`. The former allows a variable number of partitions as well as their sizes, while the latter has both a fixed number of partitions as well as their sizes (although fixed sizes does not necessarily indicate fixed \textit{equal} sizes - unequal fixed sizes also still fit the category as well).\\

At this point, part of the narrowing down of algorithm choice has already been done for us due to the limitations of the specifications of the task - the exclusion of Fixed Partioning algorithms means that we automatically avoid some of their main disadvantages, including having a fixed (and hence) inflexible number of processes that can be running at any one time, inefficient use of partition space by smaller jobs, and internal fragmentation within partitions. Not only this, but virtually no real world systems still employ the use of fixed partioning, a clear indicator of its ineffiencies and pitfalls.\\
\iffalse reference the textbook here, page 314\fi

For our available class of algorithms, they share a number of properties which for the sake of brevity will be outlined in the introduction here rather than repeated in each subsection. Memory blocks managed through dynamic algorithms do not suffer from \textit{internal fragmentation}, but rather, \textit{external fragmentation}. Whereas internal fragmentation is a more inherent problem that cannot be solved without major modifications to an algorithm itself, external fragmentation is an issue that can be solved more simply (although not without a cost) - through the use of compaction. While internal fragmentation alludes to unused space within fragments, external fragmentation is the space between allocated partitions which are unused (and potentially can't have any pending jobs slot into it). Compaction solves this by periodically (based on a factor determined by the algorithm) by packing all the memory together back into a contiguous block, external fragmentation is at that moment in time eliminated - though this has issues of its own, as it requires both time and processing power, but more importantly, the now-modified locations of memory blocks can't invalidate references that previously existed which programs relied upon.\\

The following algorithms are named based on the way in which they allocate memory to incoming programs' requests.

\subsection{Best Fit}
The \textbf{Best Fit} memory allocation algorithm, as the name suggests, will find the smallest block available that is able to fit the request which it is given, starting from the beginning. This means that each search for an appropriate block is of O(n) complexity, as an entire memory block must be traversed to determine the best-fitting block. This algorithm performs dismally, as always finding the best block means that the resulting \textit{size} of unused space (external fragmentation) is minimised - the wording of which can lead one to incorrectly believe is a positive thing, but in fact, rapidly creates a large number of miniscule, unusable blocks of memory, requiring compaction, which, as described above, is an expensive process which we want to minimise - while the Best Fit algorithm essentially maximises it instead. As a result, the best fit algorithm is in fact the worst performer of the pure dynamic allocation algorithms.\\

\textbf{However}, it is worth noting that despite its theoretical worst performance, this worst-case behaviour is often not observed, and when these cases do not surface simply due to the nature of the programs making requests to a block of memory, it doesn't necessarily perform worse than some of the other dynamic memory allocation algorithms. While some sources will find this point contentious, some (and possibly a majority) will actually claim that research has shown that Best Fit and First Fit aren't actually superior to each other in terms of wasted memory (though the latter holds) 

\subsection{Next Fit}
The \textbf{Next Fit} memory allocation algorithm will remember the last spot in which memory was last allocated (naturally, this will be the beginning if any memory is yet to be allocated), and serve requests by finding the next available block that is sufficiently large - taking O(n) time. Under normal operation, this means that what usually happens is the largest block at the `end` of memory will be quickly fragmented as processes are finishing and their allocated memory freed, and new processes with different requirements take their place. This points to a relatively frequent need to compact memory, though less so than the theoretical worst case that the Best Fit algorithm requires.

\subsection{First Fit}
The \textbf{First Fit} memory allocation algorithm search from the beginning of a memory block to find the first block that is sufficiently large to satisfy the request being made. This traversal has a complexity of O(n). Due to searching from the start every time, it takes longer than Next Fit to require breaking up blocks in the later areas of memory, which also means that theoretically, fragmentation will occur slower and hence compaction doesn't have to happen as frequently, reducing the overhead of the algorithm in this regard. However, though it holds the same complexity as Next Fit for each search, the \textit{actual} time to search is slightly higher as it has to check from the start each time, rather than simply the remaining memory left from the last allocated location. This means that during operation when not in the process of compacting, the First Fit algorithm is slower than the Next Fit algorithm. 

\subsection{Worst Fit}
The \textbf{Worst Fit} memory allocation algorithm will search from the beginning of a full memory block and find the block that is largest in difference to the request actually being made - hence it being named `worst fit`, and takes O(n) time per search. Due to the requirement from searching the entire memory space each time a request is made, its speed during operation is the same speed as that of Best Fit. \iffalse REFERENCE D. Samanta. `Classic Data Structures` 2004. p. 76\fi However, its major difference to the Best Fit algorithm is that rather than trying to minimise `wasted` space, i.e. maximise small, fragmented blocks, it does the reverse - in place of the theoretical `small, unusable` blocks created by Best Fit, Worst Fit will instead have the largest block remaining possible, leaving them available for later processes that make larger requests for available memory/.

\subsection{Buddy System}
The \textbf{Buddy System} memory allocation algorithm differs from the above in that is neither purely uses fixed or dynamic partioning schemes, but rather, a sort of combination of both.   

\iffalse (UNIX uses a version of this) Firefox uses jemalloc - an implementation of Buddy, first appeared in FreeBSD
http://stackoverflow.com/questions/1624726/how-does-jemalloc-work-what-are-the-benefits\fi

\iffalse (Justification of choice - identifies memory allocation algorithm used in code and clearly justifies choice in context of assignment - 2 marks) \fi

\section{Queuing, Dispatching, Memory Allocation, and Resource Allocation Structures}

\iffalse
(Provides thorough description of ALL dispatcher structures that are relevant to host dispatcher implementation - 5 marks + 1 bonus)

b. Describe and discuss the structures used by the dispatcher for queuing,
dispatching and allocating memory and other resources.
\fi


\section{Program Structure}

\iffalse
(12 marks + 3 bonus)
(Provides comprehensive description of overall program structure, its modules, and major functions)
(Provides detailed and clear justification of program structure in context of assignment)

c. Describe and discuss the overall structure of your program, describing the
various modules and major functions (description of the function interfaces are
expected)
\fi

\section{Discussion - Use of Multilevel Dispatching Scheme}


\iffalse
(20 marks + 5 bonus)
(Demonstrates extensive knowledge and understanding of operating systems concepts relevant to the question)
(Provides an insightful discussion of the reasons why multilevel dispatching schemes are important for process management)
(Provides an insightful comparison of the HOSTD dispatcher and other multilevel dispatching schemes used in at LEAST TWO different real operating systems)
(Outlines a range of shortcomings of the HOST dispatcher and possible improvements to address them with clear details justification)
(Refers to well-chosen examples to inform response)
(Presents a sustained, cohesive and logical response using appropriate information and ideas from a range of sources)

d. Discuss why such a multilevel dispatching scheme would be used, comparing
it with schemes used by `real` operating systems. Outline shortcomings in such a
scheme, suggesting possible improvements. Include the memory and resource
allocation schemes in your discussion
\fi

\end {document}
